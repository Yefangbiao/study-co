推荐阅读《Concurreny in go》



# Goroutine

##  Leave concurrency to the caller

把并发执行留给调用者来决定。

首先来看下面两个函数

```go
func ListDirectory(dir string) ([]string, error)

func ListDirectory(dir string) chan string
```

问题：

+ 将目录读取到一个 slice 中，然后返回整个切片，或者如果出现错误，则返回错误。这是同步调用的，ListDirectory 的调用方会阻塞，直到读取所有目录条目。根据目录的大小，这可能需要很长时间，并且可能会分配大量内存来构建目录条目名称的 slice。

+ 返回chan的方式具有几个问题
  + ListDirectory 返回一个 chan string，将通过该 chan 传递目录。当通道关闭时，这表示不再有目录。由于在 ListDirectory 返回后发生通道的填充，ListDirectory 可能内部启动 goroutine 来填充通道。
  + 通过使用一个关闭的通道作为不再需要处理的项目的信号，*ListDirectory* 无法告诉调用者通过通道返回的项目集不完整，因为中途遇到了错误。调用方无法区分空目录与完全从目录读取的错误之间的区别。这两种方法都会导致从 *ListDirectory* 返回的通道会立即关闭。
  + 调用者必须持续从通道读取，直到它关闭，因为这是调用者知道填充 *chan* 的 *goroutine* 已经停止的唯一方法。这对 *ListDirectory* 的使用是一个严重的限制，调用者必须花时间从通道读取数据，即使它可能已经收到了它想要的答案。对于大中型目录，它可能在内存使用方面更为高校，但这种方法并不比原始的基于 *slice* 的方法快。

解决:

```go
func ListDirectory(dir string, fn func(string))
```

==通常，将异步执行函数的决定权交给该函数的调用方通常更容易。==

## Never start a goroutine without konwing when it will stop

==谁创建的goroutine，谁为goroutine的生命周期负责==

如下一个函数：

```go
//模拟一个长时间的函数调用
func Search() {
	ctx, cancel := context.WithCancel(context.Background())

	// 模拟一个函数调用，花费2s
	ch := make(chan struct{})
	go func() {
		time.Sleep(2 * time.Second)
		ch <- struct{}{}
	}()

	// 一秒后执行cancel
	cancel()

	select {
	case <-ctx.Done():
		fmt.Println("ctx done")
	case <-ch:
		fmt.Println("ch done")
	}

  time.Sleep(2 * time.Second)
	// 输出2，goroutine泄露
	fmt.Println(runtime.NumGoroutine())
}
```

分析:ch是一个无缓冲通道。发送时必须有人接收。我们在1s后执行了`cancel()`。所以用`ch<-struct{}`将会一直阻塞.无人清理，造成goroutine泄露。

怎么办？

初始化ch的时候给一个缓冲区即可

```go
//模拟一个长时间的函数调用
func Search() {
	ctx, cancel := context.WithCancel(context.Background())

	// 模拟一个函数调用，花费2s
	ch := make(chan struct{}, 1)
	go func() {
		time.Sleep(2 * time.Second)
		ch <- struct{}{}
	}()

	// 一秒后执行cancel
	cancel()

	select {
	case <-ctx.Done():
		fmt.Println("ctx done")
	case <-ch:
		fmt.Println("ch done")
	}

	time.Sleep(2 * time.Second)
	// 输出1
	fmt.Println(runtime.NumGoroutine())
}
```

----

下面看看另一个例子

```go
func main() {
	go Find()
}

//模拟一个长时间的函数调用
func Find() {
	rand.Seed(time.Now().UnixNano())

	// 一个10秒内的退出函数
	t := rand.Int31n(11)
	time.Sleep(time.Duration(t) * time.Second)

	fmt.Println("函数退出")
}
```

我们无法控制`Find()`函数的生命周期。

如果我们的主函数需要退出。我们需要能够让`Find`一同退出。这有非常多种的实现方式。下面列出了一种

```go
func main() {
	wg := sync.WaitGroup{}
	wg.Add(1)
	go func() {
		defer wg.Done()

		done := Find()
		defer close(done)
		time.Sleep(3 * time.Second)
	}()
	wg.Wait()

	// 等待一下打印
	time.Sleep(1 * time.Second)
}

//模拟一个长时间的函数调用
func Find() chan struct{} {
	// 函数执行结束信号
	stop := make(chan struct{})
	// 函数正常完成信号
	done := make(chan struct{})

	go func() {
		_find(done)
		select {
		case <-stop:
			fmt.Println("函数收到信号退出")
		case <-done:
			fmt.Println("函数正常退出")
		}
	}()

	return stop
}

func _find(done chan struct{}) {
	defer close(done)
	rand.Seed(time.Now().UnixNano())

	// 一个10秒内的退出函数
	t := rand.Int31n(11)
	fmt.Printf("函数执行时间为:%ds\n", t)
	time.Sleep(time.Duration(t) * time.Second)
}
```

# Memory model

如何保证在一个 *goroutine* 中看到在另一个 *goroutine* 修改的变量的值，如果程序中修改数据时有其他 *goroutine* 同时读取，那么必须将读取串行化。为了串行化访问，请使用 *channel* 或其他同步原语，例如 *sync* 和 *sync/atomic* 来保护数据。

用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的内存重排，英文为 MemoryReordering。

## Happens Before

为了说明读和写的必要条件，我们定义了先行发生（Happens Before）。如果事件 e1 发生在 e2 前，我们可以说 e2 发生在 e1 后。如果 e1不发生在 e2 前也不发生在 e2 后，我们就说 e1 和 e2 是并发的。

当下面条件满足时，对变量 v 的读操作 r 是被允许看到对 v 的写操作 w 的：

1. *r* 不先行发生于 *w*
2. 在 *w* 后 *r* 前没有对 *v* 的其他写操作

为了保证对变量 v 的读操作 r 看到对 v 的写操作 w，要确保 w 是 r 允许看到的唯一写操作。即当下面条件满足时，r 被保证看到 w：

1. *w* 先行发生于 *r*
2. 其他对共享变量 *v* 的写操作要么在 *w* 前，要么在 *r* 后。

==这一对条件比前面的条件更严格，需要没有其他写操作与 *w* 或 *r* 并发发生。==

单个 goroutine 中没有并发，所以上面两个定义是相同的：

读操作 r 看到最近一次的写操作 w 写入 v 的值。

当多个 goroutine 访问共享变量 v 时，它们必须使用同步事件来建立先行发生这一条件来保证读操作能看到需要的写操作。 

- 对变量 *v* 的零值初始化在内存模型中表现的与写操作相同。
- 对大于 *single machine word* 的变量的读写操作表现的像以不确定顺序对多个 *single machine word* 的变量的操作。

# Package sync

## data race

*data race* 是两个或多个 *goroutine* 访问同一个资源（如变量或数据结构），并尝试对该资源进行读写而不考虑其他 *goroutine*。这种类型的代码可以创建您见过的最疯狂和最随机的 *bug*。通常需要大量的日志记录和运气才能找到这些类型的*bug*。

官方早在 1.1 版本就引入了数据竞争的检测工具，我们只需要在执行测试或者是编译的时候加上 `-race` 的 flag 就可以开启数据竞争的检测

一个有趣的例子：

```go
package main

import "fmt"

type IceCreamMaker interface {
	// Great a customer.
	Hello()
}

type Ben struct {
	name string
}

func (b *Ben) Hello() {
	fmt.Printf("Ben says, \"Hello my name is %s\"\n", b.name)
}

type Jerry struct {
	name string
}

func (j *Jerry) Hello() {
	fmt.Printf("Jerry says, \"Hello my name is %s\"\n", j.name)
}

func main() {
	var ben = &Ben{name: "Ben"}
	var jerry = &Jerry{"Jerry"}
	var maker IceCreamMaker = ben

	var loop0, loop1 func()

	loop0 = func() {
		maker = ben
		go loop1()
	}

	loop1 = func() {
		maker = jerry
		go loop0()
	}

	go loop0()

	for {
		maker.Hello()
	}
}
```

有趣的地方在于：会出现下面的问题
![image-20211101214229801](picture/image-20211101214229801.png)

我们知道，`single machine word`赋值是原子的。

在`interface`底层实现中，是有两个值得。一个是类型，另一个才是具体的值。

![image-20211101214402603](picture/image-20211101214402603.png)

上面的情况在于：`Type`被更新为`Ben`。但是对应的`Data`并没有被更新

[示例代码](https://github.com/Yefangbiao/study-co/tree/main/Go-training/go-advance/chapter3/ice_cream)

---

在这个例子中，*Ben* 和 *Jerry* 内存结构布局是相同的，因此它们在某种意义上是兼容的。想象一下，如果他们有不同的内存布局会发生什么混乱？

==会报错==:如果出现上面的情况，即`Type`和`Data`没有对应。go通过反射来找值，会panic。

---

总结：

- 善用 data race 这个工具帮助我们提前发现并发错误
- 不要对未定义的行为做任何假设，虽然有时候我们写的只是一行代码，但是 go 编译器可能后面坐了很多事情，并不是说一行写完就一定是原子的
- 即使是原子的出现了 data race 也不能保证安全，因为我们还有可见性的问题，上篇我们讲到了现代的 cpu 基本上都会有一些缓存的操作。
- 所有出现了 data race 的地方都需要进行处理

## sync.atomic

如果去看文档会发现 atomic 的函数签名有很多，但是大部分都是重复的为了不同的数据类型创建了不同的签名，这就是没有泛型的坏处了，基础库会比较麻烦

+ 第一类 `AddXXX` 当需要添加的值为负数的时候，做减法，正数做加法

```go
// 第一类，AddXXX，delta 为
func AddInt32(addr *int32, delta int32) (new int32)
func AddInt64(addr *int64, delta int64) (new int64)
func AddUint32(addr *uint32, delta uint32) (new uint32)
func AddUint64(addr *uint64, delta uint64) (new uint64)
func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)
```

+ 第二类 `CompareAndSwapXXX` CAS 操作， 会先比较传入的地址的值是否是 old，如果是的话就尝试赋新值，如果不是的话就直接返回 false，返回 true 时表示赋值成功。

```go
func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)
func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)
func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)
func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)
func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)
```

+ 第三类 `LoadXXX` ，从某个地址中取值

```go
func LoadInt32(addr *int32) (val int32)
func LoadInt64(addr *int64) (val int64)
func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)
func LoadUint32(addr *uint32) (val uint32)
func LoadUint64(addr *uint64) (val uint64)
func LoadUintptr(addr *uintptr) (val uintptr)
```

+ 第四类 `StoreXXX` ，给某个地址赋值

```go
func StoreInt32(addr *int32, val int32)
func StoreInt64(addr *int64, val int64)
func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)
func StoreUint32(addr *uint32, val uint32)
func StoreUint64(addr *uint64, val uint64)
func StoreUintptr(addr *uintptr, val uintptr)
```

+ 第五类 `SwapXXX` ，交换两个值，并且返回老的值

```go
func SwapInt32(addr *int32, new int32) (old int32)
func SwapInt64(addr *int64, new int64) (old int64)
func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)
func SwapUint32(addr *uint32, new uint32) (old uint32)
func SwapUint64(addr *uint64, new uint64) (old uint64)
func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)
```

+ 最后一类 `Value` 用于任意类型的值的 Store、Load。签名的方法都只能作用于特定的类型，引入这个方法之后就可以用于任意类型了。

```go
type Value
func (v *Value) Load() (x interface{})
func (v *Value) Store(x interface{})
```

重点讲解一下`atomic.Value`

查看下面的代码：

```go
package main

import (
	"fmt"
	"sync/atomic"
)

type Coin struct {
	Num   int
	Total int
}

func main() {
	c1 := &Coin{
		Num:   5,
		Total: 15,
	}
	c2 := &Coin{
		Num:   10,
		Total: 20,
	}

	var value atomic.Value

	var loop0, loop1 func()
	loop0 = func() {
		value.Store(c1)
		go loop1()
	}

	loop1 = func() {
		value.Store(c2)
		go loop0()
	}

	go loop0()
	for {
		fmt.Println(value.Load())
	}
}
```

绝不会出现错误的情况，与刚才的例子形成鲜明对比。

[示例代码](https://github.com/Yefangbiao/study-co/tree/main/Go-training/go-advance/chapter3/atomic)

总结:

虽然在一些情况下 atomic 的性能要好很多，但是这个是一个 low level 的库，在实际的业务代码中最好还是使用 channel 但是我们也需要知道，在一些基础库，或者是需要极致性能的地方用上这个还是很爽的，但是使用的过程中一定要小心，不然还是会容易出 bug。

`atomic.Value` 这种适合配置文件这种读特别多，写特别少的场景，因为他是 COW（Copy On Write）写时复制的一种思想，COW 就是指我需要写入的时候我先把老的数据复制一份到一个新的对象，然后再写入新的值。

> 写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。

# 补充

1. `waitGroup/atomic`并发问题

==我在结合使用waitGroup和atomic的时候遇到了一个很有意思的问题==。查看如下代码：

```go
var wg sync.WaitGroup
var counter int64

func main() {
 // 多跑几次来看结果
 for i := 1; i <= 100000; i++ {
  go routine(1)
 }
 wg.Wait()
 fmt.Printf("Final Counter: %d\n", atomic.LoadInt64(&counter))
}

func routine(id int) {
 wg.Add(1)
 defer wg.Done()
 atomic.AddInt64(&counter, 1)
}
```

在我的代码里。`waitGroup`控制并发`goroutine`。而`atomic`原子的操作`counter`。

看起来最终结果`counter`应该返回结果是`100000`。实际上经常不够。

> 哪里出现了问题？

答案在于：for循环运行的太快。

![image-20211101112353931](picture/image-20211101112353931.png)

当我们把并发执行的`每个程序/语句`想象的无限长，就可以理解了

改造：在for循环执行`wg.Add`

```go
var wg sync.WaitGroup
var counter int64

func main() {
	// 多跑几次来看结果
	for i := 1; i <= 100000; i++ {
		wg.Add(1)
		go routine(1)
	}
	wg.Wait()
	fmt.Printf("Final Counter: %d\n", atomic.LoadInt64(&counter))
}

func routine(id int) {
	defer wg.Done()
	atomic.AddInt64(&counter, 1)
}
```

