# 正则表达式

# 第一章

## 1.1正则表达式的用途

略

## 1.2如何使用正则表达式

正则表达式的基本用途：搜索和替换。给定一个正则表达式，要么匹配一些文本（进行一次搜索），要么匹配并替换一些文本（进行一次替换）。

### 1.2.1使用正则表达式进行搜索

### 1.2.2用正则表达式进行替换

# 第二章 匹配单个字符

## 正则表达式的Java命令

在教正则表达式之前，我们首先学习一些Java的基础命令能够让我们应用正则表达式。Java提供了两个类`Pattern`和`Matcher`两个类专门用于正则表达式的支持。

**Pattern对象**是正则表达式编译后在内存中的表示形式，因此，正则表达式必须先被编译为Pattern对象,然后利用Pattern对象创建对应的Matcher对象。执行匹配所涉及的状态保留在Matcher对象中，多个Matcher对象可共享同一个Pattern对象

```java
//将一个字符串编译成Pattern对象
Pattern p = Pattern.compile("a*b");
//使用Pattern创建Matcher对象
 Matcher m = p.matcher("aaaaab");
 boolean b = m.matches();

```

```java
Matcher类提供了如下几个常用方法：
①find():返回目标字符串你是否包含与Pattern匹配的字符串
②group():返回上一次与Pattern匹配的字符串
③start():返回上一次与Pattern匹配的自传在目标字符的位置
④end():返回上一次匹配的子串在目标字符串的结束位置加一
⑤loockingAt():返回目标字符串前面部分与Pattern是否匹配,不需要匹配整个区域
⑥matches():返回与整个字符串是否匹配
⑦reset():将现有的Matcher对象应用于一个新的字符序列

```

## 正则表达式的Go命令

Go语言通过 regexp 包为正则表达式提供了官方支持

```go
// 将一个字符串编译成为*Regexp对象
r := regexp.MustCompile(`^a*b$`)
// 判断子函数是否是正则表达式一部分
isMatch := r.Match([]byte("aaabbb"))
fmt.Println(isMatch) // 输出false
```





## 2.1 匹配普通文本

在正则表达式中。`Ben`是一个正则表达式，因为本身是一个普通文本，所以看起来不是一个正则表达式，但确实是。

来看下面的例子

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式 Ben
        Pattern pattern = Pattern.compile("Ben");
        String s = "Hello,My name is Ben.Please visit my website at xxx.com";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出Ben
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	// 编译正则表达式Ben
	r := regexp.MustCompile(`Ben`)
	s := []byte("Hello,My name is Ben.Please visit my website at xxx.com")
	// 判断子函数是否是正则表达式一部分
	for _, ans := range r.FindAll(s, -1) {
		// 输出Ben
		fmt.Println(string(ans))
	}
}
```

## 2.2匹配任意字符

在正则表达式里，特殊字符（或字符集合）用来标示要搜索的东西。`.`字符（英文句号）可以匹配任意字符，于是正则表达式`c.t`可以匹配到`cat`、`cot`或者其他。

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式 
        Pattern pattern = Pattern.compile("c.t");
        String s = "cat cot cht cjt asudhfauohfauiafcat";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出cat
            //cot
            //cht
            //cjt
            //cat
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`c.t`)
	s := []byte("cat cot cht cjt asudhfauohfauiafcat")
	// 判断子函数是否是正则表达式一部分
	for _, ans := range r.FindAll(s, -1) {
		// 输出cat
		//cot
		//cht
		//cjt
		//cat
		fmt.Println(string(ans))
	}
}

```

注意:`.`可以匹配任意单个字符、字母、数字甚至是 **.** 本身

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式 
        Pattern pattern = Pattern.compile("c.");
        String s = "casufhac.";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出ca
            //c.
            System.out.println(matcher.group());
        }
    }
}

```

go版本

```go
func main() {
	r := regexp.MustCompile(`c.`)
	s := []byte("casufhac.")
	// 判断子函数是否是正则表达式一部分
	for _, ans := range r.FindAll(s, -1) {
		// 输出ca
		//c.
		fmt.Println(string(ans))
	}
}
```

## 2.3匹配特殊字符

`.`字符在正则表达式里具有特殊的含义，如果模式里就需要一个`.`，就要想办法告诉正则表达式你需要的是`.`字符本身而不是它在正则表达式里面的特殊含义。为此，你需要在`.`前面加上一个`\`（反斜杠）字符来对它进行转义。`\`是一个**元字符**（metacharacter，表示“这个字符有特殊含义，代表的不是字符本身”）。因此，`.`表示匹配任意单个字符，`\.`表示匹配`.`字符本身

Ps:在其他的语言中（如Perl），一个反斜杠 `\` 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠`\\`才能被解析为其他语言中的转义作用。**我们讲解的时候会使用通用的规则**，但是编译的时候会用Java的方法，希望你能理解

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p=".c\\.";
        Pattern pattern = Pattern.compile(p);
        String s = "acot" +
                "ac." +
                "act";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出ac.
            System.out.println(matcher.group());
        }
    }
}

```

go版本

```go
func main() {
	r := regexp.MustCompile(`.c\.`)
	s := []byte("acotac.act")

	for _, ans := range r.FindAll(s, -1) {
		// 输出ac.
		fmt.Println(string(ans))
	}
}
```

可以看到只输出了`ac.` 因为我们后面匹配的是 . 字符本身



*注意*：如果想要搜索`\`本身，需要对`\`进行字符转移。相应的转义序列使`\\`。

题外话：Java想匹配`\`必须使用`\\\\`（艹）

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="\\\\";
        Pattern pattern = Pattern.compile(p);
      	//可以看出，本身的String也需要用\\来表示\\
        String s = "\\";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出\
            System.out.println(matcher.group());
        }
    }
}

```

另外，Java的`\`本身就要用来表示不能表示的字符，比如

```java
String s="abc ""
```

你注意到，最后有两个"，其中一个是字符串的一部分，所以我们需要`\`来转义一下

```java
String s="abc \""		//s就是   abc "
```

go版本

```go
func main() {
	r := regexp.MustCompile(`\\`)
	s := []byte(`\`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出\
		fmt.Println(string(ans))
	}
}
```



## 2.4 小结

正则表达式，也被称为模式，其实是由一些字符构成的字符串，这些字符可以是表面字符（普通文本）也可以是元字符（有特殊含义的字符）。在这一章，我们介绍了如何使用普通字符和元字符。`.`可以匹配任意单个字符。`\`用来对字符进行转义。

同时在Java里，我们也认识到`\`需要使用`\\\\`来表示，而表示`\.`需要使用`\\.`



# 第三章 匹配一组字符

## 3.1 匹配多个字符中的某一个

如果我们只想找出`c`或者`a`开头的后面连接`ot`的字符，就是`cot`或者`aot`，我们可以使用`[]`来定义一个字符集合，在`[]`字符集合里面的字符都是该集合的组成部分。

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="[ac]ot";
        Pattern pattern = Pattern.compile(p);
        String s = "aot" +
                "cot" +
                "dot" +
                "acot";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出aot
            //cot
            //cot
            System.out.println(matcher.group());
        }
    }
}

```

go版本

```go
func main() {
	r := regexp.MustCompile(`[ac]ot`)
	s := []byte(`aotcotdotacot`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出aot
		//cot
		//cot
		fmt.Println(string(ans))
	}
}
```

**分析**

你发现了，这里表达式`[ac]`匹配a或c，但不会两个同时匹配。另外，你可能发现了`acot`里面的`cot`也被匹配了，你可能不希望匹配`acot`,我们在后面的章节讲解这个问题

## 3.2 利用字符集合区间

在使用正则表达式的时候，会频繁使用一些区间(0-9、A-Z)等，为了简化字符区间的定义，正则表达式提供了一个特殊的元字符：可以用`-`（连字符）来定义字符区间。我们下面使用模式`[ac].[0-9]`来匹配一些例子

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="[ac].[0-9]";
        Pattern pattern = Pattern.compile(p);
        String s = "ao1" +
                "ao2" +
                "ac3" +
                "acc";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出ao1
            //ao2
            //ac3
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`[ac].[0-9]`)
	s := []byte(`a01a02ac3acc`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出a01
		//a02
		//ac3
		fmt.Println(string(ans))
	}
}
```

**分析**：模式`[0-9]`的功能与`[0123456789]`完全等价。

字符区间不仅仅限于数组，一下这些都是合法的字符区间

+ `[A-Z]`,匹配从A到Z的所有大写字母
+ `[a-z]`,匹配从a到z的所有小写字母
+ `[A-F]`,匹配从A到F的所有大写字母
+ `[A-z]`,匹配ASCII字符A到ASCII字符z的所有字母，但不推荐这么用，因为不止有字母在这个区间，如果想匹配所有大小写字母，推荐使用`[A-Za-z]`

PS：在定义一个字符区间的时候，一定要避免让这个区间尾字符小于首字符，如`[3-1]`是没有意义的，而且失效

另外，`-`是一个特殊的字符，只有出现在`[]`的时候才是元字符。在字符集意外的地方，`-`只是一个普通字符，本身就能与`-`匹配，不需要转义。

## 3.3 排除

字符集合通常用来指定一组必须匹配其中之一的字符。但在某些场合，我们需要反过来做，即指定一组不需要匹配的字符。换句话说，就是**排除字符集合里指定的那些字符**

如果你只需要把一小部分的字符排除在外，可以使用元字符`^`来排除某个集合。

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="[ac][^0-9]";
        Pattern pattern = Pattern.compile(p);
        String s = "a1" +
                "a2" +
                "a3" +
                "ac"+
                "a ";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出ac
            //a 
            System.out.println(matcher.group());
        }
    }
}

```

go版本

```go
func main() {
	r := regexp.MustCompile(`[ac][^0-9]`)
	s := []byte(`a1 a2 a3 ac a`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出ac
		fmt.Println(string(ans))
	}
}
```

分析：这里`[^0-9]`匹配任何不是数字的字符，注意，空格也是一个字符后，故匹配到了`ac`和`a(空格)  `

## 3.4 小结

元字符`[]`用来定义一个字符集合。定义一个字符集合的关系有两种：一种是列出所有字符；二是利用元字符`-`方式给出。可以利用元字符`^`排除字符集合，强制匹配指定字符集合之外的字符。

# 第四章 使用元字符

## 4.1 再谈转义

元字符是一些在正则表达式里有着特殊含义的字符。英文句号`.`是一个元字符，它可以用来匹配任意单个字符。类似的，左`[`方括号也是一个元字符。它标志着一个字符集合的开始。

因为元字符在正则表达式里有着特殊的意义，所以这些字符无法来代表它们本身。比如你不能使用`[`来匹配`[`本身，必须使用`\`转义字符进行转义，我们来看下面

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="myArray[0]";
        Pattern pattern = Pattern.compile(p);
        String s = "var myArray[0]";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //什么都没有输出
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`myArray[0]`)
	s := []byte(`var myArray[0]`)

	for _, ans := range r.FindAll(s, -1) {
		// 什么都不输出
		fmt.Println(string(ans))
	}
}
```

这里`myArray[0]`只能匹配到`myArray0`，但我们的字符和出现的不一样，这时候我们必须使用转义了

Java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="myArray\\[0\\]";
        Pattern pattern = Pattern.compile(p);
        String s = "var myArray[0]";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出myArray[0]
            System.out.println(matcher.group());
        }
    }
}

```

go版本

```go
func main() {
	r := regexp.MustCompile(`myArray\[0\]`)
	s := []byte(`var myArray[0]`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出myArray[0]
		fmt.Println(string(ans))
	}
}
```

好的，匹配成功。

我们来进阶一些，如果你不止向匹配myArray[0]，还想匹配myArray[1]，myArray[2]...

我们可以使用下面的模式`myArray\[[0-9]\]`

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="myArray\\[[0-9]\\]";
        Pattern pattern = Pattern.compile(p);
        String s = "var myArray[0]" +
                "myArray[1]" +
                "myArray[2]" +
                "myArray[3]";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出myArray[0]
            //myArray[1]
            //myArray[2]
            //myArray[3]
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`myArray\[[0-9]\]`)
	s := []byte(`var myArray[0]" +
                "myArray[1]" +
                "myArray[2]" +
                "myArray[3]`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出myArray[0]
		//myArray[1]
		//myArray[2]
		//myArray[3]
		fmt.Println(string(ans))
	}
}
```

## 4.2 匹配空白字符

元字符大致可以分为两种：一种是用来匹配文本的(比如`.`)，另一种则是正则表达式语法的组成部分（比如`[`和`]`）。随着学习的深入。你将会发现越来越多这种元字符，而我们现在要介绍的是一些用来匹配空白字符的元字符。

在进行正则表达式搜索的时候，我们经常会需要匹配文本中的非打印空白字符。比如说，你想吧制表符或者换行符找出来。直接在正则表达式输入这类字符是个棘手的事情，你可以借助下表列出的特殊元字符

​																						表4-1 空白元字符

| 元字符 |                 说明                  |
| :----: | :-----------------------------------: |
|  [\b]  | 回退（并删除）一个字符（Backspace键） |
|   \f   |                换页符                 |
|   \n   |                换行符                 |
|   \r   |                回车符                 |
|   \t   |                制表符                 |
|   \v   |              垂直制表符               |

一般来说，这些不常用，我也没有遇到对应的实例。暂且跳过

## 4.3 匹配特定的字符类型

一些常用的字符集合可以用特殊元字符来代替。这些元字符匹配的是某一类字符。称为类元字符（class metacharater）

### 4.3.1匹配数字（与非数字）

前面讲过`[0-9]`是`[0123456789]`的简写形式，可以用来匹配任何一个数字。如果你想匹配的是除数字以外的其他东西，那么把这个集合”反“过来写成`[^0-9]`就行了。下表列出了匹配数字和非数字的字符。digital：数字

| 元字符 | 说明                              |
| ------ | --------------------------------- |
| \d     | 任何一个数字字符(等价于[0-9])     |
| \D     | 任何一个非数字字符(等价于\[^0-9]) |

我们使用刚才的例子

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="myArray\\[\\d\\]";
        Pattern pattern = Pattern.compile(p);
        String s = "var myArray[0]" +
                "myArray[1]" +
                "myArray[2]" +
                "myArray[3]";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出myArray[0]
            //myArray[1]
            //myArray[2]
            //myArray[3]
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`myArray\[[\d]\]`)
	s := []byte(`var myArray[0]" +
                "myArray[1]" +
                "myArray[2]" +
                "myArray[3]`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出myArray[0]
		//myArray[1]
		//myArray[2]
		//myArray[3]
		fmt.Println(string(ans))
	}
}
```

我们使用了模式`myArray[\d]`就可以简化刚才的步骤了

如你所见，正则表达式的写法不止一种。挑选合适你的那种就可以了。

### 4.3.2 匹配字母数字（与非字母数字）

另一种频繁用到的字符集合是字母数字字符，其中包括A到Z（大小和小写）、数字0到9，以及_（常用于文件名和目录名、应用程序变量名、数据库对象名等）。

下表列出了用来匹配字母数字和非字母数字的字符类。word：字母

| 元字符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| \w     | 任何一个字母数字字符（大小写均可）或下划线字符（等价于[a-zA-Z_]） |
| \W     | 任何一个非字母数字或非下划线字符（等价于\[^a-zA-Z_]）        |

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="\\w\\W\\d\\D";
        Pattern pattern = Pattern.compile(p);
        String s = "A*2B" +
                "C(4D" +
                "E56F" +
                "G78H";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出A*2B
            //C(4D
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`\w\W\d\D`)
	s := []byte(`A*2B" +
                "C(4D" +
                "E56F" +
                "G78H`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出A*2B
		//C(4D
		fmt.Println(string(ans))
	}
}
```

### 4.3.3 匹配空白字符

下表列出了空白字符的元字符。spacing：间距，空白

| 元字符 | 说明                                     |
| ------ | ---------------------------------------- |
| \s     | 任何一个空白字符(等价于[\f\n\r\t\v])     |
| \S     | 任何一个非空白字符(等价于\[^\f\n\r\t\v]) |

### 4.3.4 匹配16进制或八进制数值

尽管你可能不需要通过十六进制或八进制来引用某个字符，但要指出的是，这么做是可以的。

1. 使用十六进制值

在正则表达式里，16进制要用前缀`\x`来给出。比如说，`\x0A`（对应ASCII字符10，也就是换行符）等价于`\n`

2. 使用八进制

8进制前缀要使用`\0`给出，数值可以是两位或者三位`\011`等价于ASCII的字符9，也就是制表符`\t`

## 4.4 使用POSIX字符类

略

## 4.5 小结

这一章介绍了使用特定字符（制表符、换行符）或字符集合或字符类（数字、字母数字字母等）的元字符。

# 第五章 重复匹配

本章将学习如何匹配多个连续重复出现的字符或字符集合

## 5.1 有多少个匹配

### 5.1.1 匹配一个或多个字符

想要匹配某个字符（或字符集合） 的一次或多次重复，只要简单的在其后面加上一个`+`字符就行了。`+`匹配一个或多个字符（至少一个，不匹配）。比如，a匹配a本身，a+匹配一个或多个连续出现的a。类似的，`[0-9]或\d`匹配单个任意数字,`[0-9]+或\d+`匹配一个或多个连续的数字。

PS：`[0-9+]`匹配的是0-9数字和+号，且匹配一个字符。

我们来匹配一下电子邮件

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="\\w+@\\w+\\.com";
        Pattern pattern = Pattern.compile(p);
        String s = "boy1's email is ben@163.com,and boy2's email is jack@gmail.com,and boy3's email is nancy@qq.com";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出ben@163.com
            //jack@gmail.com
            //nancy@qq.com
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`\w+@\w+\.com`)
	s := []byte(`boy1's email is ben@163.com,and boy2's email is jack@gmail.com,and boy3's email is nancy@qq.com`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出ben@163.com
		//jack@gmail.com
		//nancy@qq.com
		fmt.Println(string(ans))
	}
}
```

可以看到成功的匹配了电子邮件地址。`+`是一个元字符，如果想要匹配本身的话，就必须使用`\+`。

### 5.1.2 匹配零个或多个字符

`+`匹配一个或多个字符，但不匹配零个字符，`+`最少也要匹配一个字符。那么，如果想要匹配一个可有可无的字符，应该怎么办呢？

应该使用`*`来完成，`*`的用法和`+`的用法完全一样，只要放在某个字符（或字符集合的后面），就可以匹配该字符（或字符集合）出现零次或多次的情况。

PS：`.*`可以匹配任意字符，包括空字符

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="\\w+[\\w.]*@\\w+\\.com";
        Pattern pattern = Pattern.compile(p);
        String s = "boy1's email is .ben@163.com,and boy2's email is jack@gmail.com,and boy3's email is nancy@qq.com";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出ben@163.com
            //jack@gmail.com
            //nancy@qq.com
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`\w[\w.]*@[\w.]+\.\w+`)
	s := []byte(`boy1's email is .ben@163.com,and boy2's email is jack@gmail.com,and boy3's email is nancy@qq.com`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出ben@163.com
		//jack@gmail.com
		//nancy@qq.com
		fmt.Println(string(ans))
	}
}
```

### 5.1.3 匹配零个或一个字符

`?`可以匹配字符（或字符集）出现0次或一次

加入我们需要匹配网址，网址包括`http`和`https`开头，怎么办？使用`?`

看下面的实例

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="https?:\\/\\/[\\w./]+";
        Pattern pattern = Pattern.compile(p);
        String s = "ZHIHU:https://zhihu.com;" +
                "Baidu:https://baidu.com" +
                "if you input http://www.taobao.com, it will be redirect to https://www.taobao.com";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出https://zhihu.com
            //https://baidu.comif
            //http://www.taobao.com
            //https://www.taobao.com
            System.out.println(matcher.group());
        }
    }
}

```

go版本

```go
func main() {
	r := regexp.MustCompile(`https?:\/\/[\w.]+`)
	s := []byte(`ZHIHU:https://zhihu.com;" +
                "Baidu:https://baidu.com" +
                "if you input http://www.taobao.com, it will be redirect to https://www.taobao.com`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出https://zhihu.com
		//https://baidu.com
		//http://www.taobao.com
		//https://www.taobao.com
		fmt.Println(string(ans))
	}
}
```

我们在s后面加上一个元字符`?`

那么前面部分就可以匹配`http`或`https`

## 5.2 匹配的重复次数

如果我们想要对匹配的字符集合有具体的次数限制，我们可以使用元字符`{}`，并且记住，如果我们要匹配元字符，记得使用`\{ `和`\}`哦

### 5.2.1 具体的重复匹配

想要设置具体的匹配次数，把数字写在`{}`之间即可。比如说,`{3}`代表匹配前一个字符3次

我们想要匹配一个生日的年份，即连续的四个数数字，看下面

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="[\\d]{4}";
        Pattern pattern = Pattern.compile(p);
        String s = "Boy1's birthday is 1999/10/14,Boy2's birthday is 1998/2/2,Boy3's birthday is 1997/4/5";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出1999
            //1998
            //1997
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`[\d]{4}`)
	s := []byte(`Boy1's birthday is 1999/10/14,Boy2's birthday is 1998/2/2,Boy3's birthday is 1997/4/5`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出1999
		//1998
		//1997
		fmt.Println(string(ans))
	}
}
```

如果用以前的办法，我们的模式应该是`[\d][\d][\d][\d]`，现在只需要`[\d]{4}`

### 5.2.2 区间范围

`{}`可以指定匹配的最小次数和最大次数,比如`{2,4}`代表最小匹配2次，最大4次

我们还是来匹配上面的生日，可以发现月份和日期有两位的有一位的，只需要，指定最小和最大次数就可以了

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="[\\d]{4}\\/[\\d]{1,2}\\/[\\d]{1,2}";
        Pattern pattern = Pattern.compile(p);
        String s = "Boy1's birthday is 1999/10/14,Boy2's birthday is 1998/2/2,Boy3's birthday is 1997/4/5";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出1999/10/14
            //1998/2/2
            //1997/4/5
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`[\d]{4}\/[\d]{1,2}\/[\d]{1,2}`)
	s := []byte(`Boy1's birthday is 1999/10/14,Boy2's birthday is 1998/2/2,Boy3's birthday is 1997/4/5`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出1999
		//1998
		//1997
		fmt.Println(string(ans))
	}
}
```

### 5.2.3匹配”至少重复多少次“

重复范围最后一种用法是指定**至少**要匹配多少次（不指定最大匹配次数）。比如`{3,}`代表至少重复三次

下面我们从一群正数中找到，大于等于100的数字

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="[\\d]{3,4}";
        Pattern pattern = Pattern.compile(p);
        String s = "123,456,789,1,90,82,990,5897,312";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出123
            //456
            //789
            //990
            //5897
            //312
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`[\d]{3,4}`)
	s := []byte(`123,456,789,1,90,82,990,5897,312`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出123
		//456
		//789
		//990
		//5897
		//312
		fmt.Println(string(ans))
	}
}
```

PS:至少多少次一定要加上花括号里面的逗号。`{3,}`代表至少匹配三次，而`{3}`代表只匹配三次

## 5.3防止过度匹配

`?`的匹配范围有限（仅0次或者1次），当使用精确数量或区间时，重复范围匹配也是如此。但本章介绍的其他重复匹配的形式在重复次数方面没有上限，有时候这样会导致匹配过度的情况。

我们目前的例子都经过了精心的挑选，不存在匹配过度的问题，首先看看下面的例子。

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="<[Bb]>.*<[Bb]>";
        Pattern pattern = Pattern.compile(p);
        String s = "<b>this is a b tag<b><b>this is another b tag<b>";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出<b>this is a b tag<b><b>this is another b tag<b>
            System.out.println(matcher.group());
        }
    }
}
```

我们只想每个\<b>    \<b>匹配一次，结果应该输出两次，第一次是<b>this is a b tag<b>，第二次是<b>this is another b tag<b>

为什么会这样，因为`*`和`+`都是”贪婪“型元字符，其目的是匹配尽可能多，而不是适可而止，他会尽可能从一段文本开头一直到末尾，而不是碰到第一个匹配就停止。不需要这种”贪婪“的时候应该怎么办？答案是使用这些元字符的”懒惰“版本。懒惰版本是在贪婪字符后加一个`?`

| 贪婪型 | 懒惰型 |
| ------ | ------ |
| *      | *？    |
| +      | +？    |
| {n,}   | {n,}?  |

我们再次回到上面的问题

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="<[Bb]>.*?<[Bb]>";
        Pattern pattern = Pattern.compile(p);
        String s = "<b>this is a b tag<b><b>this is another b tag<b>";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出<b>this is a b tag<b>
            //<b>this is another b tag<b>
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`<[Bb]>.*?<[Bb]>`)
	s := []byte(`<b>this is a b tag<b><b>this is another b tag<b>`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出<b>this is a b tag<b>
		//<b>this is another b tag<b>
		fmt.Println(string(ans))
	}
}
```

分两次输出了我们想要的内容

## 5.4 小结

本章介绍了`+`,匹配一次或多次。`*`，匹配零次或多次。`?`：匹配0次或一次。想要更大的控制权，使用`{}`。元字符分为贪婪型和懒惰型，前者尽可能多的匹配，后者，尽可能烧的匹配。

# 第六章 位置匹配

## 6.1边界

位置匹配用于指定应该在文本中什么地方进行匹配操作。下面看一个例子

```markdown
文本
The cat scattered his food all over the room.
模式
cat
结果
The **cat** s**cat**tered his food all over the room.
```

可以看到cat匹配了文本所有的cat，即使是单词scattered的也不用例外、如果你想要匹配单个单词cat，怎么办

这时候就用到`边界`

## 6.2 单词边界

第一种边界(也是最常用到的)是由`\b`指定的单词边界。b：boundary。`\b`用来匹配一个单词的开头和结尾

我们回到刚才的例子

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="\\bcat\\b";
        Pattern pattern = Pattern.compile(p);
        String s = "The cat scattered his food all over the room";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出cat
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`\bcat\b`)
	s := []byte(`The cat scattered his food all over the room`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出cat
		fmt.Println(string(ans))
	}
}
```

输出的是单独的那个cat单词

PS:`\b`到底匹配的是什么呢？ 正则表达式并不懂英语，也不知道什么是单词边界。简单的说，`\b`匹配的是字符之间的一个位置：一边是单词（能够被`\w`匹配），另一边是其他内容(`\W`)

如果你想要匹配一个完整的单词，就必须要在匹配的文本前后都加上`\b`。

PS:`\b`匹配的是一个位置，而不是任何实际的字符。用`\bcat\b`匹配到的字符串长度是3个字符，而不是5个字符。

如果你不想匹配单词的边界，就可以使用`\B`。在下面的例子里，我们将使用`\B`来查找前后都有多余空格的非`\w`字符

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="\\B-\\B";
        Pattern pattern = Pattern.compile(p);
        String s = "The cat - scattered his food all over the room";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出-
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`\B-\B`)
	s := []byte(`The cat - scattered his food all over the room-room`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出- 第一个 - 
		fmt.Println(string(ans))
	}
}
```

`\B-\B`将匹配一个前后都不是单词边界的连字符。`nine-dight`不能匹配，但是`color - color`可以匹配

正如我们前面说的那样，同一个元字符的大写形式往往与小写形式在功能上恰好相反。下面给出一个例子请你仔细揣摩

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="\\B.\\B";
        Pattern pattern = Pattern.compile(p);
        String s = "The cat - = { } scattered his food all over the room";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出h
            //a
            //-
            // 
            //=
            // 
            //{
            // 
            //}
            //c
            //a
            //t
            //t
            //e
            //r
            //e
            //i
            //o
            //o
            //l
            //v
            //e
            //h
            //o
            //o
            System.out.println(matcher.group());
        }
    }
}

```

你是不是看到模式`\B.\B`认为只匹配`- = { }`，事实上，不止包括以上，还有空格和字符。仔细想想`\B`它功能和小写相反，即边界是大小写字符和_下划线。再想想上面的例子

## 6.3 字符串边界

单词边界可以用来对单词位置进行匹配(单词的开头、单词的结尾、整个单词等)。字符串边界有着类似的作用，不过用于在字符串首尾进行模式匹配，字符串边界元字符有两个：`^`代表字符串开头，`$`代表字符串结尾。

PS：在第三章，你已经学会了用`^`来排除某个字符集合。这个元字符怎么还用来表示字符串开头呢、

有些元字符具有多种用途，`^`就是其中之一。只有当它出现在字符集合里（位于`[]`之间，且紧跟左方括号之后，才表示排除该字符集合）.如果在字符集合之外并位于模式开头。`^`将匹配字符串的起始位置.

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="^cat";
        Pattern pattern = Pattern.compile(p);
        String s = "The cat scattered his food all over the room";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //No输出
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`^cat`)
	s := []byte(`The cat scattered his food all over the room`)

	for _, ans := range r.FindAll(s, -1) {
		// No输出
		fmt.Println(string(ans))
	}
}
```

`^`是用来检查字符串开头是不是真的某些字符，下面是正确的

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="^The";
        Pattern pattern = Pattern.compile(p);
        String s = "The cat scattered his food all over the room";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出The
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`^The`)
	s := []byte(`The cat scattered his food all over the room`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出The
		fmt.Println(string(ans))
	}
}
```

同样,`$`用法相同

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="room$";
        Pattern pattern = Pattern.compile(p);
        String s = "The cat scattered his food all over the room";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出room
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`room$`)
	s := []byte(`The cat scattered his food all over the room`)

	for _, ans := range r.FindAll(s, -1) {
		// room
		fmt.Println(string(ans))
	}
}
```

### 多行模式

正则表达式可以使用`(?m)`来启用多行模式，多行模式迫使正则表达式将换行符视为字符串分隔符，这样一来`^`既可以匹配字符串开头，也可以匹配换行符之后起始位置（新行），`$`不仅匹配字符串结尾，还能匹配换行符之后的结束位置。

在使用的时候`(?m)`必须在整个模式的最前面

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="(?m)room$";
        Pattern pattern = Pattern.compile(p);
        String s = "The cat scattered his food all over the room\n" +
                "a new room\n" +
                "another room";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出room
            //room
            //room
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`(?m)room$`)
	s := []byte("The cat scattered his food all over the room\n" +
                "a new room\n" +
                "another room")

	for _, ans := range r.FindAll(s, -1) {
		// room
		//room
		//room
		fmt.Println(string(ans))
	}
}
```

PS：有些语言的正则表达式不支持`(?m)`

## 6.4 小结

正则表达式不仅匹配任意长度文本块，还可以匹配出现在字符串中特定位置的文本。`\b`用来指定一个单词边界（与`\B`）相反。`^`和`$`用来指定字符串边界（字符串的开头和结尾）。如果与`(?m)`结合使用，`^`和`$`还可以匹配换行符之前或之后的字符串。

# 第七章 使用子表达式

本章学习如何使用子表达式(subexpression)对表达式进行分组

## 7.1 理解子表达式

我们在第5张学习了如何匹配某个字符的连续多次重复。正如之前讨论的那样，`\d+`匹配一个或多个数字字符，`https?\/\/`匹配`https://或http://`

事实上，用来表明重复次数的元字符(例如，`?`或`*`或`{2}`)只作用于紧挨着它的前一个字符或元字符.

下面举一个例子

你可能希望匹配`&nbsp;`多次，你使用了模式`&nbsp;{2,}`，但实际上只能匹配到诸如`&nbsp;;;;`这种

## 7.2 使用子表达式进行分组

子表达式必须出现在字符`()`之间，为了演示，来看一个例子

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="(&nbsp;){2,}";
        Pattern pattern = Pattern.compile(p);
        String s = "&nbsp;&nbsp;&nbsp; oh my god";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出&nbsp;&nbsp;&nbsp;
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`(&nbsp;){2,}`)
	s := []byte("&nbsp;&nbsp;&nbsp; oh my god")

	for _, ans := range r.FindAll(s, -1) {
		// 输出&nbsp;&nbsp;&nbsp;
		fmt.Println(string(ans))
	}
}
```

分析：`&nbsp`是一个子表达式，被认为是一个单一实体。因此，紧随其后的`{2,}`将作用于整个子表达式(而不仅仅是分号)。问题解决了。

## 7.3 子表达式的嵌套

子表达式允许嵌套，事实上，子表达式还可以多重嵌套，我们看一个匹配IP地址的例子

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="(\\d{1,3}.){3}(\\d{1,3})";
        Pattern pattern = Pattern.compile(p);
        String s = "12.159.22.33";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出12.159.22.33
            System.out.println(matcher.group());
        }
    }
}
```

看起来是没有什么问题的，但需要注意的是，它同样可以匹配345、700、999这些无效的IP数字，如果有办法设定取值范围，那么事情就变得简单了，但正则表达式只能匹配字符

想下IP地址规则

+ 任意的1位或2位数字
+ 任意的1开头的3位数字
+ 任意的以2开头、第二位数字在0到4之间的3个数字。
+ 任意的以25开头、第三位数字在0到5之间的3位数字。

看下面的例子

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p="(((25[0-5])|(2[0-4]\\d)|(1\\d{2})|(\\d{1,2}))\\.){3}(((25[0-5])|(2[0-4]\\d)|(1\\d{2})|(\\d{1,2})))";
        Pattern pattern = Pattern.compile(p);
        String s = "12.159.22.33";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出12.159.22.33
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`(((25[0-5])|(2[0-4]\d)|(1\d{2})|(\d{1,2}))\.){3}(((25[0-5])|(2[0-4]\d)|(1\d{2})|(\d{1,2})))`)
	s := []byte("12.159.22.33 01.234.555.2")

	for _, ans := range r.FindAll(s, -1) {
		// 输出12.159.22.33
		fmt.Println(string(ans))
	}
}
```

分析：先说四个子表达式构成的`(((25[0-5])|(2[0-4]\\d)|(1\\d{2})|(\\d{1,2}))\\.)`。我们用相反的顺序说明：`(\d{1,2})`匹配任意的一位或两位数字（0-99）;`(1\\d{2})`匹配1开头的3位数字(100-199);`(2[0-4]\\d)`匹配200-249；`(25[0-5])`匹配250-255。每个子表达式出现在括号中，彼此使用|分隔（只匹配一个即可，不用全部匹配）。随后的`\.`用来和 . 匹配。

值得注意的是，如果这四个表达式用符合逻辑的顺序来书写，反而是不行的。看下面例子

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "(((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(2[0-4]\\d)|(25[0-5]))\\.){3}(((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(2[0-4]\\d)|(25[0-5])))";
        Pattern pattern = Pattern.compile(p);
        String s = "12.159.22.200";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //输出12.159.22.20
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(2[0-4]\d)|(25[0-5]))\.){3}(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(2[0-4]\d)|(25[0-5])))`)
	s := []byte("12.159.22.200")

	for _, ans := range r.FindAll(s, -1) {
		// 12.159.22.20
		fmt.Println(string(ans))
	}
}
```

这里没有匹配所有的0，为什么呢，因为模式是从左到右匹配的，当第一个满足后，后面的就不再匹配。这里`(\d{1,2})`先匹配到了20，就不再继续向后匹配了。

## 7.4 小结

子表达式使用`()`来定义，作用是把表达式各个部分划分在一起。子表达式常见用途：通过重用次数元字符准确控制重复内容，正确定义`|`的多项分支。如果有必要，子表达式还允许嵌套使用。

## 第八章 反向引用

## 8.1 理解反向引用

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "<[Hh][1-6]>.*?<[Hh][1-6]>";
        Pattern pattern = Pattern.compile(p);
        String s = "<h1>This is H1<h1>" +
                "<h2>This is h2<h2>" +
                "<h3> This is wrong<h4>";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //<h1>This is H1<h1>
            //<h2>This is h2<h2>
            //<h3> This is wrong<h4>
            System.out.println(matcher.group());
        }
    }
}
```

go版本

```go
func main() {
	r := regexp.MustCompile(`<[Hh][1-6]>.*?<[Hh][1-6]>`)
	s := []byte(`<h1>This is H1<h1>" +
                "<h2>This is h2<h2>" +
                "<h3> This is wrong<h4>`)

	for _, ans := range r.FindAll(s, -1) {
		// 输出<h1>This is H1<h1>
		//<h2>This is h2<h2>
		//<h3> This is wrong<h4>
		fmt.Println(string(ans))
	}
}
```

我们想要找到所有标签，我们可以看到，输出中有一个错误标签

## 8.2 反向引用匹配

我们待会去解决HTML标签的问题。先来看一个比较简单的例子。

假设你有一段文本，你想把这段文本所有连续重复出现的单词找出来，需要在搜索某个单词的第二次出现的时候，这个单词必须是已知的。反向引用允许正则表达式模式引用之间匹配的结果。

看下面这个例子

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "(\\w+)[ ]+\\1";
        Pattern pattern = Pattern.compile(p);
        String s = "of of a a b b";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //of of
            //a a
            //b b
            System.out.println(matcher.group());
        }
    }
}
```

go版本：go不支持反向引用

我们来看看，`(\w+)`是一个子表达式，匹配一个或多个字母数字字符，`[ ]`匹配空格。模式最后一部分是`\1`，这是对前面子表达式的反向引用，表示匹配与第一个子表达式相同的内容。

注意：不同语言反向引用是不同的。Perl使用`$`。

我们可以来做刚才那道HTML标签问题了

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "<[Hh]([1-6])>.*?<[Hh]\\1>";
        Pattern pattern = Pattern.compile(p);
        String s = "<h1>This is H1<h1>" +
                "<h2>This is h2<h2>" +
                "<h3> This is wrong<h4>";
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            //<h1>This is H1<h1>
            //<h2>This is h2<h2>
            System.out.println(matcher.group());
        }
    }
}

```

## 8.3 替换操作

到目前位置，本书所有的正则表达式都是用来搜索的，也就是在一段文本里查找特定的内容。但并不是正则表达式的全部功能。正则表达式还可以完成各种替换操作。

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "<[Hh]([1-6])>";
        Pattern pattern = Pattern.compile(p);
        String s = "<h1>This is H1<h1>\n" +
                "<h2>This is h2<h2>\n" +
                "<h3> This is wrong<h4>";
        Matcher matcher = pattern.matcher(s);
        System.out.println(matcher.replaceAll("<H2>"));
      //输出
      //<H2>This is H1<H2>
        //<H2>This is h2<H2>
        //<H2> This is wrong<H2>
    }
}
```

go版本

````go
r := regexp.MustCompile(`<[Hh]([1-6])>`)
	s := []byte(`<h1>This is H1<h1>\n" +
                "<h2>This is h2<h2>\n" +
                "<h3> This is wrong<h4>`)

	ans := r.ReplaceAll(s, []byte("<H2>"))
	fmt.Println(string(ans))
//输出
//<H2>This is H1<H2>\n" +
// "<H2>This is h2<H2>\n" +
// "<H2> This is wrong<H2>
````

你看到了，正则表达式的替换需要两个正则表达式，一个用来搜索模式，另一个来指定替换模式，看另一个

```java

public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "(\\w+[\\w\\.]*@[\\w\\.]+\\.\\w+)";
        Pattern pattern = Pattern.compile(p);
        String s = "Ben's email is ben@163.com";
        Matcher matcher = pattern.matcher(s);
        System.out.println(matcher.replaceAll("<a herf=\"mailto:$1\">\\1<a>"));
        //Ben's email is <a herf="mailto:ben@163.com">1<a>
    }
}
```

同样可以记录子表达式，不过这里`$`用来表示第一个正则表达式的子表达式

当然，你可以使用Java字符串自带的替换方法

```java
public String replaceAll(String regex, String replacement) {
        return Pattern.compile(regex).matcher(this).replaceAll(replacement);
    }
```

### 大小写转换

有些正则表达式允许我们使用下表列出的元字符对字母进行大小写转换

| 元字符 | 说明                         |
| ------ | ---------------------------- |
| \E     | 结束\L或\U之间的转换         |
| \l     | 把下一个字符转换为小写       |
| \L     | 把\L到\E之间的字符转换为小写 |
| \u     | 把下一个字符转换为大写       |
| \U     | 把\U到\E之间字符转换为大写   |

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "(<[Hh][1-6]>)(.*?)(<[Hh][1-6]>)";
        Pattern pattern = Pattern.compile(p);
        String s = "<h1>This is H1<h1>\n" +
                "<h2>This is h2<h2>\n" +
                "<h3> This is wrong<h3>";
        Matcher matcher = pattern.matcher(s);
        System.out.println(matcher.replaceAll("$1\\L$2\\E$3"));
        //<h1>LThis is H1E<h1>
        //<h2>LThis is h2E<h2>
        //<h3>L This is wrongE<h3>
    }
}

```

目测Java不行，不能使用

## 8.4 小结

子表达式用来定义字符或表达式的集合，除了可以用于重复匹配，还可以在模式内部使用，成为反向引用。反向引用在不同与语言中有些许差异。

# 第九章 环视

目前为止，我们见过的正则表达式都是用来匹配文本的，但有时候想用正则表达式标记要匹配的文本位置(而不是文本自身)。这就要用到环视(lookaround，能够前后查看)了，这正是本章要讨论的问题。

## 9.1 环视简介

你想要在Web界面提取出标题。看下面例子

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "<[Tt][Ii][Tt][Ll][Ee]>.*?<[Tt][Ii][Tt][Ll][Ee]>";
        Pattern pattern = Pattern.compile(p);
        String s = "<head>" +
                "<title>My Web page<title>" +
                "<head>";
        Matcher matcher = pattern.matcher(s);

        while (matcher.find()) {
            //<title>My Web page<title>
            System.out.println(matcher.group());
        }
    }
}
```

但如果你仅仅想要标题文字，而不需要标签怎么办，一种办法是使用子表达式，然后只保留文字那一部分。但？太麻烦了

**你需要“环视”**

PS:所有语言支持**向前查看 **，但很少支持**向后查看**，Java,.Net,PHP,PYTHON支持向后查看

## 9.2 向前查看

向前查看指定了一个必须匹配但不用在结果中返回的模式。向前查看其实就是一个子表达式，而且从格式上看也确实如此。向前查看的语法是一个以`?=`开头的子表达式，需要匹配的文本在`=`后面.

我们来看下面的例子。下面的文本中包含了一系列URL地址，你的任务是提取每个地址的协议部分。

java版本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = ".+(?=:)";
        Pattern pattern = Pattern.compile(p);
        String s = "https://www.baidu.com\n" +
                "http://mail.forta.com\n" +
                "ftp://123.45.56.78";
        Matcher matcher = pattern.matcher(s);

        while (matcher.find()) {
            //https
            //http
            //ftp
            System.out.println(matcher.group());
        }
    }
}
```

go版本:可能不支持

上面URL地址里，协议名与主机名之间以一个`:`分隔。模式`.+`匹配任意文本，子表达式`(?=:)`匹配`:`。但是注意，被匹配到的`:`并没有出现在最终的匹配结果里。`?=`告诉正则表达式引擎，匹配`:`只为了向前查看。

## 9.3 向后查看

`?=`是向前查看。因此`?=`被称为向前查看操作符。除了向前查看，许多正则表达式还支持向后查看，也就是查看出现在已匹配文本之前的内容，向后查看操作符是`?<=`。

向后查看和向前查看一样，出现在一个子表达式里。后面要跟随匹配的文本。下面是一个例子。从一堆标价中找到产品价格

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "(?<=\\$)[\\d.]+";
        Pattern pattern = Pattern.compile(p);
        String s = "T-shirt:$3.99\n" +
                "jacket:$5.66\n" +
                "XTC99:$399.9";
        Matcher matcher = pattern.matcher(s);

        while (matcher.find()) {
            //3.99
            //5.66
            //399.9
            System.out.println(matcher.group());
        }
    }
}
```

## 9.4 结合向前查看和向后查看

回到开始的问题，你想要找到\<title>标签里的文本

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "(?<=\\<title>).*(?=\\<\\/title>)";
        Pattern pattern = Pattern.compile(p);
        String s = "<head>" +
                "<title>My Web page</title>" +
                "</head>";
        Matcher matcher = pattern.matcher(s);

        while (matcher.find()) {
            //My Web page
            System.out.println(matcher.group());
        }
    }
}
```

注意正则表达式里前面是向后查看，后面是向前查看哦。

## 9.5否定式环视

到目前为止，向前查看和向后查看通常都是用来匹配文本，主要用于指定作为匹配结果返回的文本位置。这种用法被称为**肯定式向前查看**和**肯定式向后查看**。环视还有一种不太常见的操作叫做**否定式环视**。**否定式向前查看**会向前查看不匹配指定模式的文本，**否定式向后查看**则向后查看不匹配指定模式的文本。下表列出了环视操作。

| 种类  | 说明           |
| ----- | -------------- |
| (?=)  | 肯定式向前查看 |
| (?!)  | 否定式向前查看 |
| (?<=) | 肯定式向后查看 |
| (?<!) | 否定式向后查看 |

干巴巴的讲没有意思，还是来看示例好了。

1.首先你想找到所有的价格

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "(?<=\\$)[\\d]+";
        Pattern pattern = Pattern.compile(p);
        String s = "I paid $30 for 100 apples," +
                " 50 oranges, and 60 pears." +
                "I saved $5 on this order ";
        Matcher matcher = pattern.matcher(s);

        while (matcher.find()) {
            //30
            //5
            System.out.println(matcher.group());
        }
    }
}
```

2.你想找到所有的数量

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "\\b(?<!\\$)[\\d]+\\b";
        Pattern pattern = Pattern.compile(p);
        String s = "I paid $30 for 100 apples," +
                " 50 oranges, and 60 pears." +
                "I saved $5 on this order ";
        Matcher matcher = pattern.matcher(s);

        while (matcher.find()) {
            //100
            //50
            //60
            System.out.println(matcher.group());
        }
    }
}
```

## 9.6 小结

环视可以更精确的控制最终返回结果。允许利用子表达式来指定文本匹配操作的发生位置，但同时又不会消耗匹配到的文本（不会出现在最终的匹配结果里）。肯定式向前查看使用`(?=)`来定义，否定式向前查看使用`(?！)`来定义。有些语言正则表达式支持`(?<=)`肯定式向后查看，和`(?<!)`否定式向后查看。

# 第10张章 嵌入式条件

正则表达式还有一个特性：在表达式的内部嵌入条件处理。

## 10.1 为什么要嵌入条件处理

(123)456-7890和123-456-7890都是可接受的北美电话号码格式，而1234567890、(123)-456-7890和(123-456-7890)虽然包含数目正确的数字字符，但格式都不对。如果让你来编写一个只匹配可接受格式的正则表达式，该怎么做？

下面是个简单的方法

```java
public class RegexTest {
    public static void main(String[] args) {
        //编译正则表达式
        String p = "\\(?\\d{3}\\)?-?\\d{3}-\\d{4}";
        Pattern pattern = Pattern.compile(p);
        String s = "123-456-7890 " +
                "(123)456-7890 " +
                "(123)-456-7890 " +
                "(123-456-7890 " +
                "1234567890" +
                "123 456 7890";
        Matcher matcher = pattern.matcher(s);

        while (matcher.find()) {
            //123-456-7890
            //(123)456-7890
            //(123)-456-7890
            //(123-456-7890
            System.out.println(matcher.group());
        }
    }
}
```

该模式匹配到了第三个和第四个，这是不正确的。

PS：不是所有正则表达式都支持条件处理

## 10.2 正则表达式里的条件

正则表达式的条件需要使用`？`来定义。事实上我们已经见过集中非常具体的条件了。

+ `?`匹配前一个字符或表达式，如果存在的话。
+ `?=`和`?<=`匹配前面或后面的文本，如果它存在的话。

嵌入式条件语法也使用了`?`。嵌入式条件不外乎以下两种情况。

+ 根据反向引用来进行条件处理
+ 根据环视来进行条件处理

## 10.2.1 反向引用条件

反向引用条件仅在一个前面的子表达式得以匹配的情况下才允许使用另一个表达式。

用来定义这种条件的语法是`(?(backreference)true)`,其中`?`表明是一个条件，括号里的`backreference`是一个反向引用，当反向引用出现的时候，才对表达式求值。加入我们想要得到一个\<img>标签，同时如果它外面嵌套了\<a>标签的话，也把\<a>标签输出

PS:写到这里发现 Java不支持嵌入式条件的表达，所以略

### 10.2.2 环视条件

略

# 总结

## 基本的元字符

| 元字符 | 说明                       |
| ------ | -------------------------- |
| .      | 匹配任意单个字符           |
| \|     | 逻辑或操作符               |
| []     | 匹配该字符集合中的一个字符 |
| [^]    | 排除该字符集合             |
| -      | 定义一个范围（例如[A-Z]）  |
| \      | 对下一个字符转义           |

## 量词元字符

| 元字符 | 说明                                       |
| ------ | ------------------------------------------ |
| *      | 匹配前一个字符（子表达式）的零次或多次     |
| *？    | *的懒惰版本                                |
| +      | 匹配前一个字符（子表达式）的一次或多次重复 |
| +？    | +的懒惰版本                                |
| ？     | 匹配前一个字符（子表达式）的零次或一次重复 |
| {n}    | 匹配前一个字符（子表达式）n次重复          |
| {m,n}  | 匹配前一个字符（子表达式）m到n次重复       |
| {n,}   | 匹配前一个字符（子表达式）至少n次重复      |
| {n,}?  | {n,}懒惰版本                               |

## 位置元字符

| 元字符 | 说明                       |
| ------ | -------------------------- |
| ^      | 匹配字符串的开头           |
| \A     | 匹配字符串的开头           |
| $      | 匹配字符串结尾             |
| \Z     | 匹配字符串结尾             |
| \\<    | 匹配单词开头               |
| \\>    | 匹配单词结尾               |
| \b     | 匹配单词边界（开头和结尾） |
| \B     | \b 反义                    |

## 匹配模式

`(?m)`多行模式

## 特殊字符元字符

| 元字符 | 说明               |
| ------ | ------------------ |
| [\b]   | 退格字符           |
| \c     | 匹配一个控制字符   |
| \d     | 匹配任意数字       |
| \D     | \d反义             |
| \f     | 换页符             |
| \n     | 换行符             |
| \r     | 回车符             |
| \s     | 匹配任意空格字符   |
| \S     | \s反义             |
| \t     | 制表符             |
| \v     | 垂直制表符         |
| \w     | 匹配字母数字下划线 |
| \W     | \w反义             |
| \x     | 匹配16进制         |
| \0     | 匹配8进制          |

## 反向引用和环视

| 元字符 | 说明                                      |
| ------ | ----------------------------------------- |
| ()     | 子表达式                                  |
| \1     | 匹配第一个子表达式;\2匹配第二个，依次类推 |
| ?=     | 肯定式向前查看                            |
| ?<=    | 肯定式向后查看                            |
| ?!     | 否定式向前查看                            |
| ?<!    | 否定式向后查看                            |
