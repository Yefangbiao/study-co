## 一次执行多个命令

你需要执行多个命令，但其中有些命令的运行时间较长，你又不想在输入下一个命令前等着前面的命令执行完毕。

这个问题有 3 种解决方案，第一种非常平淡无奇：不停输入就行了。Linux 或 Unix 系统足够先进，能够在处理先前命令的同时允许你继续输入，因此将命令一个接一个敲进去即可。

---

另一种解决方案也挺简单：将这些命令写入文件，然后让 bash 执行该文件（简单的 shell 脚本）中的命令。假设我们想执行 3 个命令：`long`、`medium`、`short`，这些命令名反映了各自的执行时间。我们需要按顺序执行这些命令，但又不想在输入其他命令前等着 long 脚本运行完毕。此时可以用 shell 脚本（也就是批处理文件）来完成。以下是初级做法：

```bash
$ cat > simple.script
long
medium
short
^D                      # Ctrl-D，屏幕上不可见
$ bash ./simple.script
```

----

第二种是依次执行每个命令，这无疑也是最好的解决方案。如果你想运行各个程序，不管之前的程序是否成功运行，只需要用分号将其隔开：

```bash
long ; medium ; short
```

---

如果只想在上一个程序成功运行的情况下运行下一个程序，并且所有的程序都正确设置了退出码，那么可以用 `&&` 将其隔开：

```bash
long && medium && short
```

## 同时执行多个命令

你需要执行 3 个命令，但这些命令相互独立，不必等待前一个命令运行结束。

你可以在命令末尾添加一个 `&` 符号，在后台运行该命令。这样一来，就能够连续快速地执行这 3 个命令，如下所示：

```bash
$ long &
[1] 4592
$ medium &
[2] 4593
$ short
$
```

或者，更好的做法是在单个命令行中完成所有操作。

```bash
$ long & medium & short
[1] 4592
[2] 4593
$
```

## 了解命令是否成功运行

如果编写命令或 shell 脚本的程序员遵循既定约定，那么 shell 变量 `$?` 会在命令失败时被设置为非 `0` 值。

shell 变量 `$?` 中保存着命令的退出状态，其取值范围为 `0~255`。在编写 shell 脚本时，良好的做法是：如果一切正常，脚本退出时就返回 0；如果运行过程中出错，则返回非 0 值。我们推荐只使用 `0~127` 作为返回值，因为 shell 用 128+N 代表被信号 N“杀死”。另外，如果使用的值大于 255 或小于 0，则会出现值回绕。可以用 exit 语句（如 exit 1 或 exit 0）返回退出状态。但要注意，读取命令退出状态的机会只有一次。

## 失败时退出

要想彻底检查错误，但又不想到处出现 if 语句，可以设置 `-e` 标记，这样的话，只要脚本中有任何命令（排除在 `while` 循环和 `if` 语句中，因为其本身就要用到退出状态）出现错误（退出状态为非 0），bash 就会退出。

```bash
set -e
cd mytmp
rm *
```

## 无人值守下的耗时工作

如果想在后台运行作业并在该作业完成前退出 shell，那就需要对作业使用 `nohup`。

```bash
$ nohup long &
nohup: appending output to `nohup.out'
$
```

