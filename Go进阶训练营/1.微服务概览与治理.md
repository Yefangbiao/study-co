思考

- 为什么会有微服务？
- 微服务起源？
- 微服务是什么？
- 微服务可以带来什么好处，又有那些缺点？
- 微服务的特征？
- 微服务如何构建？
- 微服务如何对外暴露？
- 微服务如何拆分？
- 如何保证微服务之间的安全？

# 微服务概览

1. 为什么会有微服务
  + 之前的巨石架构太复杂
  + 单体架构太复杂，任何开发者不可能搞懂。
  + 应用无法扩展，可靠性低。敏捷开发和部署难以完成

-------

2. 微服务起源

+ 大家经常谈论的是一个叫 SOA（面向服务的架构模式），它和微服务又是什么关系？你可以把微服务想成是 SOA 的一种实践。
+ 小即是美：小的服务代码少，bug 也少，易测试，易维护，也更容易不断迭代完善的精致进而美妙。
+ 单一职责：一个服务也只需要做好一件事，专注才能做好。
+ 尽可能早地创建原型：尽可能早的提供服务 API，建立服务契约，达成服务间沟通的一致性约定，至于实现和完善可以慢慢再做。**从类的依赖变成了服务之间的引用**
+ 可移植性比效率更重要：服务间的轻量级交互协议在效率和可移植性二者间，首要依然考虑兼容性和移植性。

------

3. 什么是微服务
  + 我特别喜欢的一个微服务定义：*“微服务架构”一词在过去几年中如雨后春笋般涌现，用来描述将软件应用程序设计为可独立部署的服务套件的特定方式。虽然这种架构风格没有精确的定义，但围绕业务能力、自动化部署、端点智能以及语言和数据的分散控制，围绕组织存在某些共同特征。*
  + 围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活

----

4. 微服务可以带来什么好处，又有那些缺点？ 

+ 优点
  + 服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展
  + **原子服务，**一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去
  + **独立进程，**一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处
  + **隔离部署，**每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本
  + 去中心化服务治理
    + 数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台
    + 治理去中心化
    + 技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的

+ 缺点

  - 服务之间的依赖关系复杂，成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。

    - 常见的解决方案：全链路追踪，例如， opentracing

  - 微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题

    - 例子：服务调用流量会容易被放大，如果 服务 A -> B ->C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的
    - **常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡**
    
  - 会有分布式事务问题，因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦
    
      - 常见解决方案：两阶段提交、TCC 等
      - [小米信息部技术团队: 分布式事务，这一篇就够了](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)
  
	- 测试会非常复杂，由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题
  
      - 常见解决方案：独立测试环境，后面会有一个解决方案
  
   - 服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。
  
      - 切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，**时刻谨记保持服务契约(接口)的兼容性**
      - 发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。
    
    - 对基础建设的要求很高，基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等
    
      - 常见解决方案：上云

---

5. 微服务的特征？**（扩展，微服务九大特性）**

+ 组件服务化
  + 传统实现组件的方式是通过库（library），库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。(巨石架构)
  + 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务：
    + *kit：一个微服务的基础库（框架）*（例如kratos）
    + *service：业务代码* *+ kit* *依赖* *+* *第三方依赖组成的业务微服务*
    + *RPC* *+ message queue：轻量级通讯*
  + 本质上说：**多个微服务组合(compose)**完成了一个完整的用户场景
+ 按照业务组织服务
  + 传统组织是按照技术层面划分的，例如： UI团队、后台团队和数据库团队。该划分方式的弊端是当业务变更发生时，需要跨团队才得以完成，成本比较高。
  + 使用全栈或者自治的方法，一个团队里可能有前后端所有的开发人员
+ 去中心化（2个）
  + 每个服务面临的业务场景不同，可以针对性选择合适的技术解决方案。但也需要避免过度多样化，结合团队实际情况来选择取舍，要是每个服务都用不同的语言的技术栈来实现，维护成本就会很高。
    + 数据去中心化：每个服务独享自身的数据存储设施**（**缓存，数据库等**）**，**不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔离相关干扰**。
    + 技术去中心化：各个服务之间不共享数据库，每个服务拥有自己独立的数据库
+ 基础设施自动化
  + 无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。
    + *CI**/**CD**：**GitLab + GitLab Hooks + Kubernetes*
    + *Testing**：测试环境、单元测试、**API* *自动化测试*
    + *在线运行时：**Kubernetes，**以及一系列* *Prometheus**、**ELK、* *Control Panel*
+ **可用性** **&** **兼容性设计**（“容错”设计）
  + 一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约（接口）的兼容性。
  + *发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。*
+ “做产品”而不是“做项目”
  + 开发人员以做产品的方式来开发服务，对其整个生命周期（包括：测试、部署及运维）负责。
+ “智能端点”与“傻瓜管道”
  + 服务自身能够自治，服务之间的交互要轻量化
    + 使用HTTP协议的RESTful API或轻量级的消息发送协议，来实现信息传递与服务调用的触发。
    + 通过在轻量级消息总线上传递消息，类似RabbitMQ等一些提供可靠异步交换的结构。
+ “演进式”设计
  + 服务可独立更换和升级
  + 需求变化是必然发生的，必须要考虑当一个服务发生变化时，依赖它并对其进行消费的其他服务将无法工作

# 微服务设计



# gRPC & 服务发现



# 多集群 & 多租户



# 阅读

+ [小米信息部技术团队: 分布式事务，这一篇就够了](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)
+ [MicroservicesAndSoa](https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa)
+ [微服务九大特性](http://kaelzhang81.github.io/2017/09/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%9D%E5%A4%A7%E7%89%B9%E6%80%A7/)
+ [微服务：从设计到部署](https://docshome.gitbook.io/microservices/1-introduction-to-microservices)

