思考

- 为什么会有微服务？
- 微服务起源？
- 微服务是什么？
- 微服务可以带来什么好处，又有那些缺点？
- 微服务的特征？
- 微服务架构演进？
- 微服务如何划分？
- 微服务如何对外暴露？
- 微服务如何拆分？
- 如何保证微服务之间的安全？

# 微服务概览

1. 为什么会有微服务
  + 之前的巨石架构太复杂
  + 单体架构太复杂，任何开发者不可能搞懂。
  + 应用无法扩展，可靠性低。敏捷开发和部署难以完成

-------

2. 微服务起源

+ 大家经常谈论的是一个叫 SOA（面向服务的架构模式），它和微服务又是什么关系？你可以把微服务想成是 SOA 的一种实践。
+ 小即是美：小的服务代码少，bug 也少，易测试，易维护，也更容易不断迭代完善的精致进而美妙。
+ 单一职责：一个服务也只需要做好一件事，专注才能做好。
+ 尽可能早地创建原型：尽可能早的提供服务 API，建立服务契约，达成服务间沟通的一致性约定，至于实现和完善可以慢慢再做。**从类的依赖变成了服务之间的引用**
+ 可移植性比效率更重要：服务间的轻量级交互协议在效率和可移植性二者间，首要依然考虑兼容性和移植性。

------

3. 什么是微服务
  + 我特别喜欢的一个微服务定义：*“微服务架构”一词在过去几年中如雨后春笋般涌现，用来描述将软件应用程序设计为可独立部署的服务套件的特定方式。虽然这种架构风格没有精确的定义，但围绕业务能力、自动化部署、端点智能以及语言和数据的分散控制，围绕组织存在某些共同特征。*
  + 围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活

----

4. 微服务可以带来什么好处，又有那些缺点？ 

+ 优点
  + 服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展
  + **原子服务，**一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去
  + **独立进程，**一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处
  + **隔离部署，**每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本
  + 去中心化服务治理
    + 数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台
    + 治理去中心化
    + 技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的

+ 缺点

  - 服务之间的依赖关系复杂，成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。

    - 常见的解决方案：全链路追踪，例如， opentracing

  - 微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题

    - 例子：服务调用流量会容易被放大，如果 服务 A -> B ->C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的
    - **常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡**
    
  - 会有分布式事务问题，因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦
    
      - 常见解决方案：两阶段提交、TCC 等
      - [小米信息部技术团队: 分布式事务，这一篇就够了](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)
  
	- 测试会非常复杂，由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题
  
      - 常见解决方案：独立测试环境，后面会有一个解决方案
  
   - 服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。
  
      - 切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，**时刻谨记保持服务契约(接口)的兼容性**
      - 发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。
    
    - 对基础建设的要求很高，基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等
    
      - 常见解决方案：上云

---

5. 微服务的特征？**（扩展，微服务九大特性）**

+ 组件服务化
  + 传统实现组件的方式是通过库（library），库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。(巨石架构)
  + 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务：
    + *kit：一个微服务的基础库（框架）*（例如kratos）
    + *service：业务代码* *+ kit* *依赖* *+* *第三方依赖组成的业务微服务*
    + *RPC* *+ message queue：轻量级通讯*
  + 本质上说：**多个微服务组合(compose)**完成了一个完整的用户场景
+ 按照业务组织服务
  + 传统组织是按照技术层面划分的，例如： UI团队、后台团队和数据库团队。该划分方式的弊端是当业务变更发生时，需要跨团队才得以完成，成本比较高。
  + 使用全栈或者自治的方法，一个团队里可能有前后端所有的开发人员
+ 去中心化（2个）
  + 每个服务面临的业务场景不同，可以针对性选择合适的技术解决方案。但也需要避免过度多样化，结合团队实际情况来选择取舍，要是每个服务都用不同的语言的技术栈来实现，维护成本就会很高。
    + 数据去中心化：每个服务独享自身的数据存储设施**（**缓存，数据库等**）**，**不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔离相关干扰**。
    + 技术去中心化：各个服务之间不共享数据库，每个服务拥有自己独立的数据库
+ 基础设施自动化
  + 无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。
    + *CI**/**CD**：**GitLab + GitLab Hooks + Kubernetes*
    + *Testing**：测试环境、单元测试、**API* *自动化测试*
    + *在线运行时：**Kubernetes，**以及一系列* *Prometheus**、**ELK、* *Control Panel*
+ **可用性** **&** **兼容性设计**（“容错”设计）
  + 一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约（接口）的兼容性。
  + *发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。*
+ “做产品”而不是“做项目”
  + 开发人员以做产品的方式来开发服务，对其整个生命周期（包括：测试、部署及运维）负责。
+ “智能端点”与“傻瓜管道”
  + 服务自身能够自治，服务之间的交互要轻量化
    + 使用HTTP协议的RESTful API或轻量级的消息发送协议，来实现信息传递与服务调用的触发。
    + 通过在轻量级消息总线上传递消息，类似RabbitMQ等一些提供可靠异步交换的结构。
+ “演进式”设计
  + 服务可独立更换和升级
  + 需求变化是必然发生的，必须要考虑当一个服务发生变化时，依赖它并对其进行消费的其他服务将无法工作

# 微服务设计

![01_Go进阶训练营_微服务_v1.svg](1.微服务概览与治理.assets/1606552913072-f2ae26c9-6897-4dc8-9384-95f493ff5006.svg)

1. 微服务架构演进？

我们进行了 SOA 服务化的架构演进，按照垂直功能进行了拆分，对外暴露了一批微服务，但是因为缺乏统一的出口面临了不少困难

![image-20211009212344404](1.微服务概览与治理.assets/image-20211009212344404.png)

+ 客户端到微服务直接通信，强耦合
+ 需要多次请求，客户端聚合数据，工作量巨大，延迟高（请求AI服务，稿件服务，广告服务......）
+ 协议不利于统一，各个部门之间有差异，需要端来兼容（各个部门可能有自己的一套协议）
+ 面向“端”的API适配，耦合到了内部服务（ipad版本、安卓版本的API适配问题。ipad、安卓版本可能api有需要不同适配的地方）
+ 多终端兼容逻辑复杂，每个服务都需要处理（因为直接耦合微服务，老版本的api无法下线）
+ 统一逻辑无法收敛，比如安全认证、限流

2. 新增API Gateway

我们新增了一个 app-interface 用于统一的协议出口，在服务内进行大量的 dataset join，按照业务场景来设计==粗粒度的 API==，给后续服务的演进带来的很多优势

![image-20211009212854096](1.微服务概览与治理.assets/image-20211009212854096.png)

+ 轻量交互：协议精简、聚合（不同的终端提供相同的API，可以聚合不同的协议）
+ 差异服务：数据剪裁以及聚合、针对终端定制化API
+ 动态升级：原有系统兼容升级，更新服务而非协议（API兼容，服务随时更新）
+ 沟通效率提升，协作模式演进为移动业务+网关小组

3. API Gateway的问题

最致命的一个问题是整个 app-interface 属于 single point of failure，严重代码缺陷或者流量洪峰可能引发集群宕机。

+ *单个模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线 BFF 和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下。*
+ *很多跨横切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多。*

4. 抽出横切面的功能

![image-20211009214348619](1.微服务概览与治理.assets/image-20211009214348619.png)

跨横切面（Cross-Cutting Concerns）的功能，需要协调更新框架升级发版（路由、认证、限流、安全），因此全部上沉，引入了 *API Gateway*，把业务集成度高的 BFF 层和通用功能服务层 API Gateway 进行了分层处理

*在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF 实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专注业务逻辑交付，实现了架构上的关注分离（Separation of Concerns）。*

>  业务的实际流量

*移动端* *-> API Gateway -> BFF -> Microservices，在* *FE Web**业务中，**BFF* *可以是* *Node.js* *来做服务端渲染（**SSR**，**Server-Side Rendering**），注意这里忽略了上游的* *CDN**、**4/7**层负载均衡（**ELB）。*

5. 微服务如何划分

微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能（Business Capability）或是 DDD 的限界上下文（Bounded Context）。

+ *Business Capability*

    *由公司内部不同部门提供的职能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。*

+ *Bounded Context*

    *限界上下文是 DDD 中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。*

+ CQRS，将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新

  ![image-20211009215538426](1.微服务概览与治理.assets/image-20211009215538426-3787740.png)

  *在稿件服务演进过程中，我们发现围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，我们依赖稿件数据库* *binlog* *以及订阅* *binlog* *的中间件* *canal，将我们的稿件结果发布到消息队列* *Kafka* *中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来拆分复杂架构和业务。*

  ==最终变成了命令端和查询段解耦==

# gRPC & 服务发现



# 多集群 & 多租户



# 补充

1. SOA架构
2. BFF:面向前端应用的后端服务
3. DDD领域驱动设计

# 阅读

+ [小米信息部技术团队: 分布式事务，这一篇就够了](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)
+ [Redis与MySQL双写一致性如何保证](https://zhuanlan.zhihu.com/p/413827571?utm_source=qq&utm_medium=social&utm_oi=827092282342801408)
+ [MicroservicesAndSoa](https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa)
+ [微服务九大特性](http://kaelzhang81.github.io/2017/09/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%9D%E5%A4%A7%E7%89%B9%E6%80%A7/)
+ [微服务：从设计到部署](https://docshome.gitbook.io/microservices/1-introduction-to-microservices)

